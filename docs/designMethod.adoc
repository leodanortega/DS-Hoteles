=== Método de diseño

El diseño arquitectónico del Sistema Hotelero se desarrolló siguiendo el método Attribute-Driven Design (ADD) 3.0, complementado con el enfoque de Domain-Driven Design (DDD) para la partición de dominios.

Este método garantiza que la arquitectura resultante no sea producto de decisiones arbitrarias, sino una respuesta racional a los impulsores arquitectónicos (drivers). El objetivo fue transformar los atributos de calidad priorizados en el Utility Tree (Escalabilidad, Disponibilidad, Mantenibilidad) en las estructuras modulares definidas en la Vista Lógica.

==== Enfoque general del proceso ADD

El diseño se desarrolló en iteraciones, donde cada ciclo buscó satisfacer un conjunto de drivers arquitectónicos seleccionando tácticas y patrones específicos.

*Identificación de drivers:*
Se tomaron como entrada las restricciones (CON-01 a CON-10) y los escenarios del Utility Tree con prioridad (H, H) y (H, M).

*Descomposición del sistema:*
A diferencia de un enfoque monolítico tradicional, se optó por un estilo de **Microservicios** asistido por patrones de **Interfaz (BFF)**. Esta decisión estructural responde a la necesidad crítica de escalabilidad independiente y tolerancia a fallos parciales.

==== Iteraciones del proceso ADD

A continuación, se documenta cómo se tomaron las decisiones arquitectónicas en cada iteración:

===== Iteración 1: Usabilidad y Desacoplamiento de UI

*Drivers atendidos:*
* **QAS01 (Usabilidad):** Curva de aprendizaje mínima y respuesta fluida.
* **CRN-10 (UX Fluida):** Minimizar fricción en flujos clave.
* **CON-01:** Uso de React para el frontend.

*Decisiones tomadas:*
1.  **Separación Frontend-Backend (SPA):** Se decidió mover toda la lógica de presentación al cliente (Single Page Application), comunicándose vía REST. Esto elimina las recargas de página completas.
2.  **Patrón Backend for Frontend (BFF):** Dado que el sistema tiene distintos tipos de usuarios (Huésped Web vs. Recepcionista Desktop), se introdujo una **Capa de Acceso** intermedia. Cada BFF formatea y agrega los datos específicamente para su cliente, evitando que el frontend tenga que hacer múltiples llamadas complejas y mejorando la latencia percibida.

*Resultado:*
Una estructura donde la Capa de Cliente es independiente y ligera, soportada por una Capa de Acceso (BFF) que optimiza la experiencia de usuario.

===== Iteración 2: Escalabilidad y Estructura de Negocio

*Drivers atendidos:*
* **QAS14 (Escalabilidad):** Elasticidad ante picos del 300% de tráfico.
* **QAS10 (Modificabilidad):** Cambios en reglas de negocio sin redestiegue total.

*Decisiones tomadas:*
1.  **Estilo de Microservicios (Bounded Contexts):** Se descompuso el backend monolítico en servicios independientes (*Inventario, Reservas, Pagos, Estancias*) basándose en los dominios de negocio.
2.  **Base de Datos por Servicio:** Para permitir que el servicio de *Inventario* escale (muchas lecturas) independientemente del servicio de *Pagos* (transaccionalidad estricta), se decidió que cada servicio sea dueño de su propio esquema de datos, evitando bases de datos compartidas que crean cuellos de botella.

*Resultado:*
Definición de la **Capa de Negocio**, compuesta por servicios autónomos que pueden escalar horizontalmente según la demanda específica de su dominio.

===== Iteración 3: Disponibilidad y Resiliencia

*Drivers atendidos:*
* **QAS07 (Resiliencia BD):** Recuperación ante caída de base de datos.
* **QAS04 (Fallo Externo):** Manejo de caída de la pasarela de pagos.

*Decisiones tomadas:*
1.  **Comunicación Asíncrona (Event-Driven):** Para procesos no bloqueantes como el envío de correos o la sincronización con OTAs, se introdujo un **Bus de Mensajes** (Infraestructura Transversal). Esto evita que un fallo en el servidor de correo tumbe la transacción de reserva.
2.  **Patrón Circuit Breaker:** Se aplicó en la comunicación entre servicios (ej. Reservas -> Pagos) para evitar fallos en cascada cuando un servicio dependiente está lento o caído.

*Resultado:*
Una arquitectura resiliente donde los fallos se aíslan en el componente origen. Consolidación de la **Capa de Infraestructura Transversal**.

===== Iteración 4: Seguridad y Estandarización

*Drivers atendidos:*
* **QAS03 (Seguridad PCI):** Protección de datos en tránsito y reposo.
* **QAS09 (DDoS):** Protección contra ataques de red.

*Decisiones tomadas:*
1.  **API Gateway:** Se introdujo un punto único de entrada para todo el tráfico externo. Este componente maneja la autenticación (JWT), la terminación SSL y el *Rate Limiting*, descargando a los microservicios de estas responsabilidades.
2.  **Arquitectura Hexagonal Interna:** Dentro de cada microservicio, se separó el Dominio de la Infraestructura mediante puertos y adaptadores, facilitando el cumplimiento de seguridad (ej. cambiar el adaptador de persistencia para encriptar datos sin tocar la lógica de negocio).

*Resultado:*
Protección perimetral robusta en la Capa de Acceso y diseño interno de servicios preparado para auditoría y evolución.

==== Cierre del proceso

El resultado final es una arquitectura organizada en cuatro capas lógicas claras, alineadas con el diagrama de paquetes:

1.  **Capa de Clientes:** SPAs y aplicaciones clientes.
2.  **Capa de Acceso:** API Gateway y BFFs.
3.  **Capa de Negocio:** Microservicios autónomos (Core).
4.  **Capa de Infraestructura:** Persistencia, Mensajería y Servicios Externos.

Esta estructura sustituye al modelo tradicional de tres capas (Presentación-Negocio-Datos) para satisfacer los exigentes requisitos de escalabilidad y mantenibilidad del proyecto.

=== Decisiones Arquitectónicas Significativas (ADR)

A continuación se resumen las decisiones clave que han dado forma a la arquitectura del sistema, extraídas y consolidadas a partir del proceso de diseño.

include::adrs.adoc[]