== Método de Diseño Arquitectónico

A continuación se describe el proceso racional, iterativo e incremental seguido para derivar la arquitectura del Sistema de Gestión Hotelera (SGH) a partir de sus impulsores. Este enfoque garantiza que cada decisión de diseño esté directamente justificada por su contribución a los objetivos de negocio y a los atributos de calidad.

=== ADD y CBSE

Para la creación de la arquitectura del SGH, se adoptó un proceso híbrido que combina la guía estratégica del método Attribute-Driven Design (ADD) con las prácticas de especificación del Component-Based Software Engineering (CBSE), siguiendo el enfoque de Cheesman & Daniels.

El método ADD se utilizó como el marco principal para la toma de decisiones. Este enfoque asegura que la arquitectura sea moldeada por sus impulsores más críticos: los atributos de calidad (refinados a partir de las preocupaciones), las restricciones y los requisitos funcionales. El proceso de ADD nos obliga a justificar cada decisión importante en función de cómo ayuda a satisfacer uno o más de estos impulsores, evitando así un diseño arbitrario. Partimos de los impulsores de más alta prioridad para realizar una descomposición inicial del sistema, eligiendo patrones y tácticas arquitectónicas que los satisfagan.

Una vez que ADD nos proporciona una descomposición de alto nivel, utilizamos el proceso de especificación de CBSE para refinar y detallar los componentes identificados:

Identificación: A partir de los casos de uso y el modelo de dominio del negocio (Hoteles, Habitaciones, Reservaciones, Huéspedes), identificamos los componentes de negocio candidatos que encapsulan la lógica y los datos relacionados.

Interacción: Modelamos cómo estos componentes interactúan para realizar las operaciones del sistema (ej. ReservarHabitación). Esto nos permite refinar sus responsabilidades y definir las interfaces preliminares que necesitarán para colaborar.

Este ciclo de descomposición (ADD) y especificación (CBSE) se repite en cada iteración, permitiendo un diseño incremental y refinado.

=== Priorización de Atributos y Backlog

Para guiar las decisiones arquitectónicas, primero definimos cuáles atributos de calidad son los más críticos. Utilizamos una matriz de priorización donde comparamos los atributos entre sí.

.Matriz de priorización de atributos
image::../images/priorizacionAtributos.png[Priorización de atributos, width=600, align=center]

El resultado indica que la **Seguridad** es el atributo dominante, seguido de la **Disponibilidad**. Esto se justifica dado que manejamos datos sensibles de tarjetas de crédito y operamos en tiempo real.

==== Backlog de Impulsores Arquitectónicos (Drivers)

A partir de la priorización, formalizamos el backlog de impulsores que moldearán la arquitectura:

* **Seguridad (Confidencialidad - CRN-01):** Proteger los datos de pago y personales. Una brecha aquí es fatal para la reputación y legalidad del negocio.
* **Disponibilidad (Resiliencia - CRN-02):** El sistema debe tolerar fallos en servicios externos (como la pasarela de pagos) y picos de demanda sin caerse.
* **Consistencia de Datos (Integridad - CRN-03):** Evitar estrictamente el *overbooking*. El inventario debe ser consistente entre consultas y reservas.
* **Rendimiento (Tiempo de Respuesta - CRN-04):** Respuestas en < 2 segundos para búsquedas. Vital para la retención del cliente en el portal web.
* **Usabilidad (Eficiencia - CRN-10):** Minimizar la curva de aprendizaje para los recepcionistas (alta rotación de personal) y facilitar la reserva al huésped.
* **Escalabilidad (CRN-05):** Soportar el crecimiento horizontal de la cadena hotelera sin rediseñar el sistema.

=== Diseño por iteraciones

El diseño se ejecutó en dos iteraciones principales, cada una con un objetivo claro y enfocada en un conjunto de impulsores priorizados.

==== Iteración 1: Núcleo Transaccional y de Disponibilidad

El objetivo primordial de esta primera iteración fue diseñar el esqueleto arquitectónico del sistema, enfocado en los flujos de negocio más críticos y los atributos de calidad más desafiantes: la consulta de disponibilidad y la creación de una reserva. La meta era asegurar que el núcleo del sistema fuera robusto, seguro, escalable y consistente desde su concepción.

La alta prioridad de impulsores como la Consistencia del Inventario (CRN-03), la Alta Disponibilidad (CRN-02) y el Rendimiento Bajo Carga (CRN-04) nos llevó a tomar la decisión fundamental de adoptar un estilo arquitectónico de microservicios. Esta decisión, aunque introduce complejidad, es una táctica que nos permite abordar múltiples preocupaciones simultáneamente: permite que los componentes escalen de forma independiente (CRN-05), que un fallo en un servicio no afecte a todo el sistema (CRN-02) y fomenta la mantenibilidad a largo plazo (CRN-07).

Para la consistencia del inventario (CRN-03), se decidió utilizar una combinación de tácticas. Se optó por un bloqueo optimista en la base de datos del servicio de inventario. Cuando un usuario inicia una reserva, el sistema verifica la versión del registro de la habitación; si al momento de confirmar la reserva la versión ha cambiado, significa que otro proceso la modificó, la transacción falla y se le notifica al usuario. Para transacciones que abarcan múltiples servicios (reserva, pago, notificación), se adoptará el patrón Saga para gestionar la consistencia distribuida y asegurar que una reserva fallida pueda ser revertida limpiamente en todos los sistemas implicados.

Para garantizar la disponibilidad (CRN-02) y el rendimiento (CRN-04), se diseñó el despliegue con redundancia de componentes, con múltiples instancias de cada microservicio corriendo detrás de un balanceador de carga. Además, se introdujo una capa de caché distribuida (táctica de rendimiento) para las consultas de disponibilidad, reduciendo la carga sobre la base de datos principal y mejorando drásticamente los tiempos de respuesta para las búsquedas comunes.

Finalmente, para la seguridad (CRN-01) y la gestión centralizada de las interacciones, se adoptó el patrón API Gateway. Este componente actúa como el único punto de entrada para todas las solicitudes del cliente, encargándose de la autenticación (CON-05), la autorización, el enrutamiento a los servicios internos y la aplicación de políticas de limitación de tasa (rate limiting) para prevenir abusos.

==== Cierre de la Iteración 1
[cols="1,3", options="header"]
|===
|Elemento |Descripción

|Drivers Atendidos
|

Primarios: CRN-01 (Seguridad), CRN-02 (Disponibilidad), CRN-03 (Consistencia), CRN-04 (Rendimiento).

Secundarios: CRN-06 (Auditabilidad - sentando las bases), CON-01 (Stack Tecnológico), CON-02 (Nube), CON-03 (Pasarela de Pagos), CON-05 (Autenticación).

|Decisiones Registradas
|

Adopción del estilo arquitectónico de Microservicios como macro-patrón.

Implementación de un API Gateway para centralizar la seguridad y el enrutamiento.

Uso de bloqueo optimista para la gestión de concurrencia en el inventario.

Adopción del patrón Saga para transacciones distribuidas.

Diseño de despliegue con redundancia de componentes y balanceo de carga.

Introducción de una caché distribuida para optimizar las consultas de disponibilidad.
|===


==== Iteración 2: Experiencia de Usuario y Operaciones del Hotel

Con el núcleo transaccional definido, la segunda iteración se centró en la Experiencia de Usuario (CRN-10) y la Mantenibilidad (CRN-07) de las aplicaciones cliente y los servicios de soporte operativo.

El impulsor de ofrecer una experiencia de usuario fluida (CRN-10) y la restricción de usar React (CON-01) nos llevaron a diseñar el portal de huéspedes como una Single-Page Application (SPA). Esta táctica mejora la percepción del rendimiento al evitar recargas completas de la página, comunicándose con el backend a través de llamadas asíncronas.

Al analizar los flujos de trabajo del personal de recepción y de los administradores, se hizo evidente que sus necesidades de datos y funcionalidades eran muy diferentes a las de un huésped. Para evitar la creación de una API monolítica y compleja, y para fomentar la mantenibilidad (CRN-07), se adoptó el patrón Backend for Frontend (BFF). Se diseñaron tres APIs distintas: una para el frontend de huéspedes, una para el sistema de recepción y otra para el panel de administración. Cada BFF es responsable de agregar y adaptar los datos de los microservicios del backend para servir eficientemente a su cliente específico.

Finalmente, para la gestión de notificaciones (confirmaciones de reserva, cancelaciones, etc.), y para mejorar la escalabilidad (CRN-05) y la resiliencia (CRN-02), se decidió desacoplar este proceso. Se introdujo un broker de mensajes (táctica de comunicación asíncrona). Cuando ocurre un evento como "reserva_confirmada", el servicio de reservas publica un mensaje en una cola. Un servicio de notificaciones, separado e independiente, consume este mensaje y se encarga de enviar el correo o la notificación push. Si el servicio de notificaciones falla, los mensajes permanecen en la cola y pueden ser procesados más tarde, sin afectar el flujo de reserva principal.

==== Cierre de la Iteración 2
[cols="1,3", options="header"]
|===
|Elemento |Descripción

|Drivers Atendidos
|

Primarios: CRN-10 (Experiencia de Usuario), CRN-07 (Mantenibilidad).

Secundarios: CRN-05 (Escalabilidad), CRN-08 (Observabilidad - al desacoplar flujos), CRN-12 (Interoperabilidad - mediante APIs bien definidas).

|Decisiones Registradas
|

Diseño del portal de huéspedes como una Single-Page Application (SPA).

Adopción del patrón Backend for Frontend (BFF) para crear APIs especializadas.

Uso de un broker de mensajes para la comunicación asíncrona y el desacoplamiento de notificaciones.

Separación de las aplicaciones frontend en al menos tres bases de código distintas: Huésped, Recepción y Administración.
|===

==== Iteración 3: Especificación de Interfaces y Flujos Guiados

Objetivo de la iteración: Definir los contratos exactos de comunicación entre los BFFs y los clientes, y refinar la usabilidad para tareas complejas del personal, cerrando la brecha entre la arquitectura y la implementación.

Drivers Atendidos: #5 (Usabilidad) y #6 (Interoperabilidad/Mantenibilidad).

Decisiones de Diseño (Tácticas y Patrones):

Diseño de Contratos Primero (API First): Antes de codificar, se definen las interfaces usando la especificación OpenAPI. Esto permite que los equipos de Frontend y Backend trabajen en paralelo.
Flujos Guiados: Para el driver de Usabilidad del recepcionista (QAS05), se decidió implementar patrones de "Mago" en la interfaz. En lugar de un formulario gigante para el Check-In, el sistema divide el proceso en pasos pequeños y validados secuencialmente.
Validación en Cliente y Servidor: Se especifica que las reglas de negocio críticas se validen en el frontend para feedback inmediato, pero se re-validen obligatoriamente en el backend por seguridad.

Criterios de "Suficiente":
La iteración concluye cuando los diagramas de secuencia de las operaciones críticas (Check-in, Pago) coinciden con los contratos OpenAPI definidos y los prototipos de UI son aprobados.

==== Cierre de la Iteración 3

[cols="1,3", options="header"]
|===
|Elemento |Descripción

|Drivers Atendidos
|Primarios: CRN-10 (Usabilidad). Secundarios: CRN-07 (Mantenibilidad).

|Decisiones Registradas
|
Uso de OpenAPI para contratos estrictos entre BFF y Clientes.
Implementación de Flujos Guiados para procesos operativos complejos.
Estrategia de doble validación para UX y Seguridad.
|===

== Especificacion

Esta sección detalla los componentes lógicos que resultaron del proceso de diseño por iteraciones.

=== Identificación de Core Types

image::IdentificacionDeCores.jpg[Identificación de core types, width=600, align=center]

=== Especificación inicial de interfaces de negocio

image::DiagramaInterfaces.jpg[Identificación inicial de interfaces, width=60, align=center]

=== Justificación de la Descomposición del Sistema

La arquitectura resultante se basa en la descomposición del dominio en sistemas autónomos (Microservicios de grano grueso), cada uno con una responsabilidad clara y delimitada. Esta estructura modular permite que cada sistema evolucione, escale y se despliegue de forma independiente, cumpliendo directamente con los atributos de **Escalabilidad** y **Mantenibilidad** definidos en el backlog.

1.  **SistemaCadenaHotel**
    * Propósito: Gestión corporativa y estratégica.
    * Responsabilidad: Centraliza la configuración global de la cadena (nuevos hoteles, políticas generales). Es el punto de control para el `AdministradorDeLaCadena`. No participa en la operación día a día de un hotel específico.

2.  **SistemaHotel**
    * Propósito: Gestión operativa local.
    * Responsabilidad: Administra el inventario físico (habitaciones), servicios, productos y empleados de una sede específica. Es la fuente de verdad sobre "qué tiene el hotel".

3.  **SistemaHuesped**
    * Propósito: Gestión de identidad y perfiles (CRM).
    * Responsabilidad: Almacena y protege los datos personales y preferencias de los clientes. Centraliza la autenticación y el historial del cliente para ofrecer una experiencia personalizada.

4.  **SistemaReservacionEstancia**
    * Propósito: Núcleo transaccional del negocio.
    * Responsabilidad: Orquesta el ciclo de vida principal: Reservar -> Check-In -> Estancia -> Check-Out.
    * Complejidad: Es el sistema que más interactúa con los demás, validando disponibilidad con `SistemaHotel` y datos con `SistemaHuesped`. Garantiza la integridad de las fechas y evita el overbooking.

5.  **SistemaPagos (PasarelaPagos)**
    * Propósito: Gestión financiera segura.
    * Responsabilidad: Encapsula la complejidad de comunicarse con proveedores externos (bancos/Stripe/PayPal). Provee una interfaz unificada para realizar cargos y reembolsos, aislando al resto del sistema de los detalles de cumplimiento PCI-DSS.